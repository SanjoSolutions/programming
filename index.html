<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Programming</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      .error {
        color: red;
        margin-top: 0.25rem;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <textarea id="code" rows="10" style="width: 100%;"></textarea>
    <button id="run">Run</button>
    <button id="reset">Reset</button>
    <div class="error" style="display: none;"></div>
    <script>
      const RIGHT = 0
      const BOTTOM = 0.5 * Math.PI
      const LEFT = Math.PI
      const TOP = 1.5 * Math.PI

      const canvas = document.getElementById('canvas')
      const context = canvas.getContext('2d')

      const $error = document.querySelector('.error')

      let unit = null

      const _ = ' '
      const o = 'o'
      const x = 'x'

      const levels = [
        {
          map: [
            [_, o, o]
          ],
          unit: { row: 0, column: 0, angle: 0 }
        },
        {
          map: [
            [_, o],
            [o, o]
          ],
          unit: { row: 0, column: 0, angle: 0 }
        },
        {
          map: [
            [_, o, o],
            [o, x, o],
            [o, o, o]
          ],
          unit: { row: 0, column: 0, angle: 0 }
        }
      ]

      let currentLevelIndex = null

      function changeLevel(levelIndex) {
        currentLevelIndex = levelIndex
        currentLevel = copyLevel(levels[currentLevelIndex])
        unit = { ...currentLevel.unit }
      }

      changeLevel(0)

      function copyLevel(level) {
        return {
          map: copyMap(level.map),
          unit: {...level.unit}
        }
      }

      function copyMap(map) {
        const mapCopy = Array.from(map)
        for (let rowIndex = 0; rowIndex < mapCopy.length; rowIndex++) {
          mapCopy[rowIndex] = Array.from(mapCopy[rowIndex])
        }
        return mapCopy
      }

      function renderLevel() {
        context.clearRect(0, 0, canvas.width, canvas.height)
        const map = currentLevel.map
        for (let rowIndex = 0; rowIndex < map.length; rowIndex++) {
          const row = map[rowIndex]
          for (let columnIndex = 0; columnIndex < row.length; columnIndex++) {
            const cell = row[columnIndex]
            if (cell === o) {
              renderO({ row: rowIndex, column: columnIndex })
            } else if (cell === x) {
              renderX({ row: rowIndex, column: columnIndex })
            }
          }
        }
        renderUnit(unit)
      }

      const size = 10

      function renderUnit({row, column, angle}) {
        context.fillStyle = 'green'
        context.fillRect(column * size, row * size, size, size)
        context.fillStyle = 'white'
        let width
        let height
        switch (angle) {
          case RIGHT:
          case LEFT:
            width = size / 2
            height = 2
            break
          case TOP:
          case BOTTOM:
            width = 2
            height = size / 2
            break
        }
        let x
        let y
        switch (angle) {
          case RIGHT:
            x = column * size + 0.5 * size
            y = row * size + 0.5 * size - 1
            break
          case LEFT:
            x = column * size
            y = row * size + 0.5 * size - 1
            break
          case TOP:
            x = column * size + 0.5 * size - 1
            y = row * size
            break
          case BOTTOM:
            x = column * size + 0.5 * size - 1
            y = row * size + 0.5 * size
            break
        }
        context.fillRect(x, y, width, height)
      }

      function renderO({ row, column }) {
        context.fillStyle = 'brown'
        context.fillRect(column * size, row * size, size, size)
      }

      function renderX({ row, column }) {
        context.fillStyle = 'black'
        context.fillRect(column * size, row * size, size, size)
      }

      renderLevel()

      const $run = document.getElementById('run')
      const $reset = document.getElementById('reset')
      const $code = document.getElementById('code')

      let queue = null

      function moveForward() {
        queue.push({action: 'move forward'})
      }

      function turnLeft() {
        queue.push({ action: 'turn left' })
      }

      function turnRight() {
        queue.push({ action: 'turn right' })
      }

      $run.addEventListener('click', async function () {
        $error.style.display = 'none'
        $error.textContent = ''
        queue = []
        const code = $code.value
        try {
          eval(code)
        } catch (error) {
          $error.textContent = 'Error: ' + error.message
          $error.style.display = 'block'
        }
        await run()
      })

      $reset.addEventListener('click', function () {
        currentLevel = copyLevel(levels[currentLevelIndex])
        unit = {...currentLevel.unit}
        renderLevel()
      })

      async function run() {
        const map = currentLevel.map
        while (queue.length >= 1) {
          const action = queue.shift()
          switch (action.action) {
            case 'move forward':
              if (unit.angle === RIGHT) {
                unit.column++
              } else if (unit.angle === TOP) {
                unit.row--
              } else if (unit.angle === LEFT) {
                unit.column--
              } else if (unit.angle === BOTTOM) {
                unit.row++
              }
              if (map[unit.row][unit.column] === o) {
                map[unit.row][unit.column] = _
              }
              break
            case 'turn left':
              unit.angle = (unit.angle - 0.5 * Math.PI) % (2 * Math.PI)
              break
            case 'turn right':
              unit.angle = (unit.angle + 0.5 * Math.PI) % (2 * Math.PI)
              if (unit.angle < 0) {
                unit.angle += 2 * Math.PI
              }
              break
          }
          renderLevel()
          if (hasCompletedLevel()) {
            if (isThereANextLevel()) {
              changeToTheNextLevel()
            }
            return
          }
          await wait(1000)
        }
      }

      function hasCompletedLevel() {
        const map = currentLevel.map
        for (let rowIndex = 0; rowIndex < map.length; rowIndex++) {
          const row = map[rowIndex]
          for (let columnIndex = 0; columnIndex < row.length; columnIndex++) {
            const cell = row[columnIndex]
            if (cell === o) {
              return false
            }
          }
        }
        return true
      }

      function isThereANextLevel() {
        return currentLevelIndex < levels.length - 1
      }

      function changeToTheNextLevel() {
        changeLevel(calculateNextLevelIndex())
        renderLevel()
      }

      function calculateNextLevelIndex() {
        return currentLevelIndex + 1
      }

      async function wait(duration) {
        return new Promise(resolve => setTimeout(resolve, duration))
      }
    </script>
  </body>
</html>
