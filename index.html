<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Programming</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <textarea id="code" rows="10" style="width: 100%;"></textarea>
    <button id="run">Run</button>
    <button id="reset">Reset</button>
    <script>
      const canvas = document.getElementById('canvas')
      const context = canvas.getContext('2d')

      let player = null

      const _ = ' '
      const o = 'o'
      const x = 'x'

      const levels = [
        {
          map: [
            [_, o, o]
          ],
          player: { row: 0, column: 0, angle: 0 }
        },
        {
          map: [
            [_, o],
            [o, o]
          ],
          player: { row: 0, column: 0, angle: 0 }
        },
        {
          map: [
            [_, o, o],
            [o, x, o],
            [o, o, o]
          ],
          player: { row: 0, column: 0, angle: 0 }
        }
      ]

      let currentLevelIndex = null

      function changeLevel(levelIndex) {
        currentLevelIndex = levelIndex
        currentLevel = copyLevel(levels[currentLevelIndex])
        player = { ...currentLevel.player }
      }

      changeLevel(0)

      function copyLevel(level) {
        return {
          map: copyMap(level.map),
          player: {...level.player}
        }
      }

      function copyMap(map) {
        const mapCopy = Array.from(map)
        for (let rowIndex = 0; rowIndex < mapCopy.length; rowIndex++) {
          mapCopy[rowIndex] = Array.from(mapCopy[rowIndex])
        }
        return mapCopy
      }

      function renderLevel() {
        context.clearRect(0, 0, canvas.width, canvas.height)
        const map = currentLevel.map
        for (let rowIndex = 0; rowIndex < map.length; rowIndex++) {
          const row = map[rowIndex]
          for (let columnIndex = 0; columnIndex < row.length; columnIndex++) {
            const cell = row[columnIndex]
            if (cell === o) {
              renderO({ row: rowIndex, column: columnIndex })
            } else if (cell === x) {
              renderX({ row: rowIndex, column: columnIndex })
            }
          }
        }
        renderI(player)
      }

      const size = 10

      function renderI({row, column}) {
        context.fillStyle = 'green'
        context.fillRect(column * size, row * size, size, size)
      }

      function renderO({ row, column }) {
        context.fillStyle = 'brown'
        context.fillRect(column * size, row * size, size, size)
      }

      function renderX({ row, column }) {
        context.fillStyle = 'black'
        context.fillRect(column * size, row * size, size, size)
      }

      renderLevel()

      const $run = document.getElementById('run')
      const $reset = document.getElementById('reset')
      const $code = document.getElementById('code')

      let queue = null

      function moveForward() {
        queue.push({action: 'move forward'})
      }

      function turnLeft() {
        queue.push({ action: 'turn left' })
      }

      function turnRight() {
        queue.push({ action: 'turn right' })
      }

      $run.addEventListener('click', async function () {
        queue = []
        const code = $code.value
        eval(code)
        await run()
      })

      $reset.addEventListener('click', function () {
        currentLevel = copyLevel(levels[currentLevelIndex])
        player = {...currentLevel.player}
        renderLevel()
      })

      async function run() {
        const map = currentLevel.map
        while (queue.length >= 1) {
          const action = queue.shift()
          switch (action.action) {
            case 'move forward':
              if (player.angle === 0) {
                player.column++
              } else if (player.angle === 0.5 * Math.PI) {
                player.row--
              } else if (player.angle === Math.PI) {
                player.column--
              } else if (player.angle === 1.5 * Math.PI) {
                player.row++
              }
              if (map[player.row][player.column] === o) {
                map[player.row][player.column] = _
              }
              break
            case 'turn left':
              player.angle = (player.angle + 0.5 * Math.PI) % (2 * Math.PI)
              break
            case 'turn right':
              player.angle = (player.angle - 0.5 * Math.PI) % (2 * Math.PI)
              if (player.angle < 0) {
                player.angle += 2 * Math.PI
              }
              break
          }
          renderLevel()
          if (hasCompletedLevel()) {
            if (isThereANextLevel()) {
              changeToTheNextLevel()
            }
            return
          }
          await wait(1000)
        }
      }

      function hasCompletedLevel() {
        const map = currentLevel.map
        for (let rowIndex = 0; rowIndex < map.length; rowIndex++) {
          const row = map[rowIndex]
          for (let columnIndex = 0; columnIndex < row.length; columnIndex++) {
            const cell = row[columnIndex]
            if (cell === o) {
              return false
            }
          }
        }
        return true
      }

      function isThereANextLevel() {
        return currentLevelIndex < levels.length - 1
      }

      function changeToTheNextLevel() {
        changeLevel(calculateNextLevelIndex())
        renderLevel()
      }

      function calculateNextLevelIndex() {
        return currentLevelIndex + 1
      }

      async function wait(duration) {
        return new Promise(resolve => setTimeout(resolve, duration))
      }
    </script>
  </body>
</html>
